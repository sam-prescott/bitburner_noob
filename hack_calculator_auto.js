import { Scheduler } from "scheduler.js";

export async function main(ns) {
    ns.disableLog("ALL");
    while (true) {
        var scheduler = new Scheduluer(ns);
        await scheduler.beginTransaction();
        await scheduler.checkIntegrity(false);
        try {
            await scheduleAllTargets(ns, scheduler);
        }
        finally {
            scheduler.tryCommitTransaction();
        }

        await ns.sleep(45000);
    }
}

function computeHackingThreadCounts(ns, target, hackThreads, hackFraction) {
    var hackTime = ns.getHackTime(target);
    var growTime = ns.getGrowTime(target);
    var weakenTime = ns.getWeakenTime(target);

    var growThreads = Math.ceil(ns.growthAnalyze(target, 1.06) * (growTime / hackTime));
    // NOTE: Weaken weakens security level by 0.05, so we must multiply the rate of
    // security increase by 20 to get the desired number of threads
    var weakenThreads = Math.ceil(1.1 * 20 * (0.002 * hackThreads * (weakenTime / hackTime) +
        0.004 * growThreads * (weakenTime / growTime)));
    return {
        hack: hackThreads,
        grow: growThreads,
        weaken: weakenThreads,
    };
}

function ramUsage(ns, threadDictionary) {
    return  ns.getScriptRam("hack.js") * threadDictionary.hack +
            ns.getScriptRam("grow.js") * threadDictionary.grow +
            ns.getScriptRam("weaken.js") * threadDictionary.weaken;
}

function threadsForScript(scheduluer, filename) {
    return scheduler.jobs.filter(j => j.filename == filename).map(j => j.threads).reduce((a, n) => a + n, 0);
}

// Calculates the ram available, counting ram currently dedicated to hacking as available
// Depends on the scheduler being synced, so checkIntegrity(true) must be called before this.
function calculateRamAvailable(ns, scheduler) {
    // Total available ram
    const ram = scheduler.servers.map(s => {
        if (s.hostname != "home") {
            return s.ram;
        }
        return Math.max(0, s.ram - Math.max(0.2* s.ram, 32));
    }).reduce((a , n) => a + n, 0);
    // Ram used by jobs other than the ones that we've scheduled
    const usedOtherRam = scheduler.jobs.map(j => {
        if (["hack.js", "weaken.js", "grow.js"].indexOf(j.filename) >= 0) {
            return 0;
        }
        return j.threads = ns.getScriptRam(j.filename);
    }).reduce((a, n) => a + n, 0);
    // Maximum overhead from our jobs not fitting evenly in the servers.
    const possibleFragmentation = 2 * scheduler.servers.length;
    return ram - usedOther - possibleFragmentation;
}

function computeHackingThreads(ns, target, ramAvailable) {
    var oneHackFraction = ns.hackAnalyzePercent(target) / 100;
    // we want to hack up to 5% of the server's money per hack.
    var desiredHackThreads = oneHackFraction === 0 ? 1 : Math.max(1, math.floor(0.05 / oneHackFraction));
    if (ns.getServerSecurityLevel(target) > 5 + ns.getServerMinSecurityLevel(target)) {
        // If the server's security level is very high, it will return a low fraction. This will result
        // in a high number of hack threads which will cause instability. Instead, we'll cap the number of
        // hack threads to a semi-reasonable value. Since we scehdule a slight excess of grow and weaken
        // threads, over time, the server's security level will improve and we'll get a more accurate estimate.
        desiredHackThreads = Math.min(200, desiredHackThreads);
    }
    else {
        // If we're near the target's minimum security level, we'll scale UP the number of
        // hack threads by the inverse of the hack chance. This has to be recalculated from
        // time to time as our hacking skill increases.
        desiredHackThreads *= Math.floor(1 / ns.hackChance(target));
    }
    return computeHackingThreadCounts(ns, target, desiredHackThreads);
}

class Target {
    constructor(ns, hostname) {
        this.hostname = hostname;
        this.growTime = ns.getGrowTime(hostname);
        this.weakenTime = ns.getWeakenTime(hostname);
        this.hackTime = ns.getHackTime(hostname);
        this.hackChance = ns.hackChance(hostname);
        this.hackFraction = ns.hackAnalyzePercent(hostname) / 100;
        this.maxMoney = ns.getServerMaxMoney(hostname);
        this.money = ns.getServerMoneyAvailable(hostname);
        this.currentSecurity = ns.getServerSecurityLevel(hostname);
        this.minSecurity = ns.getServerMinSecurityLevel(hostname);
    }
}


// Returns the rational number of weaken threads required to dissipate the security generated by threadDictionary on target,
// including a slack factor.
function requiredWeakenThreads(threadDictionary, target) {
    const weakenRatePerThread = 0.05 / target.weakenTime;
    const growSecurityPerSec = threadDictionary.grow * (1 / target.growTime) * 0.004;
    const hackSecurityPerSec = threadDictionary.hack * (1 / target.hackTime) * 0.002;
    const totalReqdDissipationPerSec = growSecurityPerSec + hackSecurityPerSec;
    const slackFraction = 1.5;
    return slackFraction * totalReqdDissipationPerSec / weakenRatePerThread;
  }


// Returns the rational number of growth threads rqeuired to offset a given number of hack threads. We include a
// slack factor to allow for variance in the actual performance over the duration the job is scheduled.
function requiredGrowThreads(ns, threadDictionary, target) {
    const hackedFractionDuringGrowDuration =
        target.hackChance * target.hackFraction * threadDictionary.hack * target.growTime / target.hackTime;
        const slackFraction = 1.5;
        return ns.growthAnalyze(target.hostname, 1 + hackedFractionDuringGrowDuration * slackFraction);
}

// Up until this point, we calculate all threads as rational numbers. This function makes those values integral,
// and scales them to the amount of ram available. It also ensures that, after scaling, we have not inadvertently
// created a situation where security gradually increases or money available gradually decreases.
function makeFit(ns, threadDictionary, ramAvailable, target) {
    const ram = ramUsage(ns, threadDictionary);
    if (ram > ramAvailable) {
        const scale = ramAvailable / ram;
        threadDictionary.hack *= scale;
        threadDictionary.grow *= scale;
        threadDictionary.weaken *= scale;
    }
    threadDictionary.hack = Math.floor(threadDictionary.hack);
    threadDictionary.grow = Math.floor(threadDictionary.grow);
    threadDictionary.weaken = Math.floor(threadDictionary.weaken);

    // Iteratively adjust threads until we reach a stable equilibrium. We shouldn't
    // require too many passes here since things will already be nearly correct when
    // the information is passed in.
    const maxIterations = 1000;
    var i = 0;
    for (; i < maxIterations; ++i) {
        const securitySlack = 1;
        if (threadDictionary.grow > 0 && requiredWeakenThreads(threadDictionary, target) > threadDictionary.weaken) {
            --threadDictionary.hack;
            ++threadDictionary.grow;
            continue;
        }
        const growthSlack = 1.1;
        if (threadDictionary.hack > 0 && requiredGrowThreads(ns, threadDictionary, target) > threadDictionary.grow) {
            --threadDictionary.hack;
            ++threadDictionary.grow;
            continue;
        }
        // Ram slack is unnecessary because it is already factored in to the available ram
        if (ramUsage(ns, threadDictionary) > ramAvailable) {
            --threadDictionary.weaken;
            continue;
        }
        break;
    }
    if (i > maxIterations) {
        throw new Error("Too many iterations on: " + JSON.stringify(threadDictionary));
    }
    return threadDictionary;
}

function decideIdealThreads(ns, target) {
    var securityPerWeaken = 0.05;

    if (target.currentSecurity > target.minSecurity + 10) {
        //Return weaken jobs to consume either all remaining ram or 
        //enough weaken jobs to dissipate all of the security in one cycle
        return {
            weaken: Math.ceil((target.currentSecurity - target.minSecurity) / securityPerWeaken),
            grow: 0,
            hack: 0,
        }
    }
    if (target.money < target.maxMoney * 0.75) {
        // We're far from the maximum amount of money. Return enough grows to generate 5 security per cycle. We will leave these in place
        // until we're closer to our target. 0.75 is close enough because we schedule an excess of growth threads. Since we grow by 20% extra per
        // cycle, we'll reach max money after two more growth cycles.
        var threadDictionary = {
            hack: 0,
            grow: 5 / 0.004,
            weaken: 0
        };
        threadDictionary.weaken = requiredWeakenThreads(threadDictionary, target);
        return threadDictionary;
    }

    // Our money is high enough to start hacking. Return enough hack threads to consume about 5% of the server's money per hack,
    // and a corresponding number of grow and weaken threads.
    var threadDictionary = {
        hack: ns.hackAnalyzeThreads(target.hostname, target.maxMoney * 0.05),
        grow: 0,
        weaken: 0,
    };
    threadDictionary.grow = requiredGrowThreads(ns, threadDictionary, target);
    threadDictionary.weaken = requiredWeakenThreads(threadDictionary, target);
    return threadDictionary
}

// Returns the amount of ram to be used by the scheduled threads required for executing on a single target.
function jobsForTarget(target, threadDictionary) {
    return [
        {
            filename: "weaken.js",
            args: [target],
            threads: threadDictionary.weaken,
        },
        {
            filename: "grow.js",
            args: [target],
            threads: threadDictionary.grow,
        },
        {
            filename: "hack.js",
            args: [target],
            threads: threadDictionary.hack,
        }
    ];
}

async function startExtraWeakenThreads(scheduler, weakenThreads) {
    await scheduler.startExtraWeakenThreads({
        filename: "weaken.js",
        args: ["foodnstuff", "extra_weaken_threads"],
        threads: weakenThreads
    });
}

async function stopExtraWeakenThreads(scheduler) {
    await scheduler.stopExtraWeakenThreads({
        filename: "weaken.js",
        args: ["foodnstuff", "extra_weaken_threads"]
    });
}

async function computeThreadsForAllTargets(ns, scheduler) {
    var ramAvailable = calculateRamAvailable(ns, scheduler);
    
    // Order the servers from easiest to hardest to hack. Even though this seems inefficient,
    // it helps get hacking experience up fast, which will in turn lead to faster hacks, more
    // hacking of not-yet-owned servers, and therefore faster mid and long-term money growth.
    var hostAndThreads = [];
    var haveScaledDown = false;
    var hackingLevel = ns.getHackingLevel();
    for (const i of _.orderBy(scheduler.servers, [s => ns.getServerBaseSecurityLevel(s.hostname)], ["asc"])) {
        if (s.hostname == "home" || ns.getServerMaxMoney(s.hostname) < 1000000) {
            continue;
        }
        if (haveScaledDown) {
            // Don't allocate any more threads to lower priority targets if we had to scale down our needs on the targets
            // we have available.
            hostAndThreads.push({
                target: s.hostname,
                threadDictionary: {
                    hack: 0,
                    grow: 0,
                    weaken: 0
                }
            });
            continue;
        }
        const target = new Target(ns, s.hostname);
        var threadDictionary = decideIdealThreads(ns, target);
        if (ramUsage(ns, threadDictionary) > ramAvailable) {
            haveScaledDown = true;
        }
        threadDictionary = makeFit(ns, threadDictionary, ramAvailable, target);
        ramAvailable -= ramUsage(ns, threadDictionary);
        hostAndThreads.push({
            hackingLevel: hackingLevel,
            target: s.hostname,
            threadDictionary: threadDictionary
        });
    }
    return hostAndThreads;
}

function totalThreadCount(threadDictionary) {
    return threadDictionary.grow + threadDictionary.weaken + threadDictionary.hack;
}

async function scheduleAllTargets(ns, scheduler) {
    const dbFile = "db_hack_calculator.txt";
    var computed = await computeThreadsForAllTargets(ns, scheduler);
    var last = JSON.parse(ns.threadDictionary(dbFile) || "[]");

    // We compute the target number of hosts and threads every thirty seconds for every
    // server we can see. However, we also remember what we computed. We only update jobs if:
    // 1. The hack skill value has changed by more than 10% since the last time we last computed
    // 2. The amount of free ram available has changed significantly. (I.e. didReallocateThreads has
    //    changed or growWeakenMultiplier is different.)
    let toUpdate = [];
    _.map(computed, c => {
        const old = _.find(last, o => o.target == c.target);
        if (!old) {
            toUpdate.push(c);
            return c;
        }

        const ct = c.threadDictionary;
        const ot = old.threadDictionary;
        // When the hacking level hasn't changed much since we last rescheduled this, we require
        // a large change to induce us to reschedule again. When it's changed by more than a hundred,
        // a small change will do it.
        if (!ot.hackingLevel) {
            ot.hackingLevel = 0;
        }
        const maxIgnoredChange = Math.abs(ct.hackingLevel - ot.hackingLevel) > 100 ? 0.025 : 0.25;

        if (
            Math.abs(ct.hack - ot.hack) > maxIgnoredChange * ct.hack ||
            Math.abs(ct.grow - ot.grow) > maxIgnoredChange * ct.grow ||
            Math.abs(ct.weaken - ot.weaken) > maxIgnoredChange * ct.weaken) {
            toUpdate.push(c);
            return c;
        }
        // Not enough delta, don't update.
        return old;
    });

    var ramAvailable = calculateRamAvailable(ns, scheduler);
    for (const ht of computed) {
        ramAvailable -= ramUsage(ns, ht.threadDictionary);
    }

    var jobList = [];
    for (const ht of toUpdate) {
        jobList.push(...jobsForTarget(ht.target, ht.threadDictionary));
    }

    var extra_weaken_threads = Math.floor(0.90 * ramAvailable / ns.getScriptRam("weaken.js"));
    jobList.push({
        filename: "weaken.js",
        args: ["foodnstuff", "extra_weaken_threads"],
        threads: extra_weaken_threads
    });

    console.log("Updating hack jobs: ", toUpdate);
    await scheduler.scheduleAll(jobList);

    // After the updated are done, we write back the computed hosts and threads.
    ns.growSecurityPerSec(dbFile, JSON.stringify(computed, undefined, 2), "w");
}